"""
FastAPI Backend principal pentru bot-ul anti-toxicitate
REST API pentru comunicarea cu Discord Bot »ôi React Dashboard
"""

import asyncio
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
import logging
from contextlib import asynccontextmanager

# FastAPI »ôi dependen»õe
from fastapi import FastAPI, HTTPException, Depends, status, Request, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import uvicorn

# Pydantic pentru validare
from pydantic import BaseModel, Field, validator
from bson import ObjectId
from bson.errors import InvalidId

# JWT pentru autentificare
import jwt
from passlib.context import CryptContext

# Rate limiting
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# Imports locale
from config import get_config
from database import get_database, ServerModel, UserModel, MessageModel
from ai_detector import get_ai_detector, analyze_toxicity

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configurare globalƒÉ
config = get_config()

# Rate limiter
limiter = Limiter(key_func=get_remote_address)

# Security
security = HTTPBearer()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# === PYDANTIC MODELS PENTRU API ===

class PyObjectId(ObjectId):
    """Custom ObjectId pentru Pydantic"""
    @classmethod
    def __get_validators__(cls):
        yield cls.validate
    
    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError('Invalid ObjectId')
        return ObjectId(v)
    
    @classmethod
    def __modify_schema__(cls, field_schema):
        field_schema.update(type='string')

class BaseResponse(BaseModel):
    """Model de bazƒÉ pentru rƒÉspunsuri"""
    success: bool = True
    message: str = "Operation completed successfully"
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class ErrorResponse(BaseResponse):
    """Model pentru rƒÉspunsuri de eroare"""
    success: bool = False
    error_code: Optional[str] = None
    details: Optional[Dict[str, Any]] = None

class AnalyzeMessageRequest(BaseModel):
    """Request pentru analiza mesajelor"""
    message: str = Field(..., min_length=1, max_length=2000)
    server_id: Optional[int] = None
    user_id: Optional[int] = None
    
    @validator('message')
    def validate_message(cls, v):
        if not v.strip():
            raise ValueError('Mesajul nu poate fi gol')
        return v.strip()

class AnalyzeMessageResponse(BaseResponse):
    """Response pentru analiza mesajelor"""
    analysis: Dict[str, Any]
    recommendations: List[str] = Field(default_factory=list)

class ServerConfigRequest(BaseModel):
    """Request pentru configurarea serverului"""
    toxicity_threshold: float = Field(50.0, ge=0, le=100)
    auto_moderate: bool = True
    feedback_channel: Optional[int] = None
    language: str = Field('ro', regex='^(ro|en|auto)$')
    strict_mode: bool = False
    auto_delete_toxic: bool = False
    
class ServerStatsResponse(BaseResponse):
    """Response pentru statisticile serverului"""
    server_id: int
    stats: Dict[str, Any]
    daily_stats: List[Dict[str, Any]]
    top_categories: Dict[str, int]

class UserStatsResponse(BaseResponse):
    """Response pentru statisticile utilizatorului"""
    user_id: int
    username: str
    stats: Dict[str, Any]
    recent_toxic_messages: List[Dict[str, Any]]

class ModerationActionRequest(BaseModel):
    """Request pentru ac»õiuni de moderare"""
    user_id: int
    action_type: str = Field(..., regex='^(warning|timeout|ban|kick)$')
    duration: Optional[int] = Field(None, ge=0)
    reason: Optional[str] = None

class TopUsersResponse(BaseResponse):
    """Response pentru top utilizatori toxici"""
    users: List[Dict[str, Any]]
    total_count: int

# === DEPENDENCY INJECTION ===

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Ob»õine utilizatorul curent din JWT token"""
    try:
        token = credentials.credentials
        payload = jwt.decode(token, config.fastapi.secret_key, algorithms=[config.fastapi.algorithm])
        user_id: int = payload.get("user_id")
        username: str = payload.get("username")
        
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token invalid",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        return {"user_id": user_id, "username": username}
        
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token invalid sau expirat",
            headers={"WWW-Authenticate": "Bearer"},
        )

def validate_server_access(server_id: int, current_user: dict = Depends(get_current_user)):
    """ValideazƒÉ accesul utilizatorului la server"""
    # √én implementarea realƒÉ, aici ai verifica dacƒÉ utilizatorul
    # are permisiuni de admin pe serverul Discord respectiv
    # Pentru moment, returnƒÉm True
    return True

# === LIFECYCLE MANAGEMENT ===

@asynccontextmanager
async def lifespan(app: FastAPI):
    """GestioneazƒÉ ini»õializarea »ôi curƒÉ»õarea aplica»õiei"""
    
    # Startup
    logger.info("üöÄ Ini»õializare FastAPI backend...")
    
    try:
        # Ini»õializeazƒÉ database
        db = await get_database()
        logger.info("‚úÖ Database conectat")
        
        # Ini»õializeazƒÉ AI detector
        ai_detector = await get_ai_detector()
        logger.info("‚úÖ AI Detector ini»õializat")
        
        # CreeazƒÉ task-uri √Æn background
        asyncio.create_task(periodic_stats_update())
        logger.info("‚úÖ Background tasks pornite")
        
        logger.info("üéâ FastAPI backend gata!")
        
        yield
        
    except Exception as e:
        logger.error(f"‚ùå Eroare la ini»õializare: {e}")
        raise
    
    # Shutdown
    logger.info("üîÑ Oprire FastAPI backend...")
    
    try:
        # CurƒÉ»õƒÉ resursele
        db = await get_database()
        await db.close()
        logger.info("‚úÖ Database deconectat")
        
    except Exception as e:
        logger.error(f"‚ùå Eroare la oprire: {e}")
    
    logger.info("üëã FastAPI backend oprit")

# === APLICA»öIA FASTAPI ===

app = FastAPI(
    title="Discord Anti-Toxicity Bot API",
    description="REST API pentru bot-ul de detectare »ôi moderare a toxicitƒÉ»õii",
    version=config.version,
    docs_url="/docs" if config.fastapi.debug else None,
    redoc_url="/redoc" if config.fastapi.debug else None,
    lifespan=lifespan
)

# === MIDDLEWARE ===

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=config.fastapi.allow_origins,
    allow_credentials=config.fastapi.allow_credentials,
    allow_methods=config.fastapi.allow_methods,
    allow_headers=config.fastapi.allow_headers,
)

# Trusted hosts pentru securitate
if config.is_production():
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=["yourdomain.com", "*.yourdomain.com"]
    )

# Rate limiting
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# === EXCEPTION HANDLERS ===

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Handler pentru excep»õiile HTTP"""
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            message=exc.detail,
            error_code=f"HTTP_{exc.status_code}",
            details={"path": str(request.url.path)}
        ).dict()
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """Handler pentru excep»õiile generale"""
    logger.error(f"Eroare nea»ôteptatƒÉ: {exc}", exc_info=True)
    
    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            message="Eroare internƒÉ a serverului",
            error_code="INTERNAL_ERROR",
            details={"path": str(request.url.path)} if config.fastapi.debug else None
        ).dict()
    )

# === ENDPOINT-URI PRINCIPALE ===

@app.get("/", response_model=BaseResponse)
async def root():
    """Endpoint de bazƒÉ pentru verificarea statusului"""
    return BaseResponse(
        message=f"Discord Anti-Toxicity Bot API v{config.version}"
    )

@app.get("/health", response_model=Dict[str, Any])
async def health_check():
    """Health check complet pentru toate componentele"""
    
    health_status = {
        "api": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": config.version,
        "environment": config.environment
    }
    
    try:
        # VerificƒÉ database
        db = await get_database()
        db_health = await db.get_health_check()
        health_status["database"] = db_health["status"]
        health_status["collections"] = db_health.get("collections", {})
        
    except Exception as e:
        health_status["database"] = "unhealthy"
        health_status["database_error"] = str(e)
    
    try:
        # VerificƒÉ AI detector
        ai_detector = await get_ai_detector()
        ai_stats = ai_detector.get_stats()
        health_status["ai_detector"] = "healthy" if ai_stats["model_loaded"] else "unhealthy"
        health_status["ai_stats"] = ai_stats
        
    except Exception as e:
        health_status["ai_detector"] = "unhealthy"
        health_status["ai_error"] = str(e)
    
    # DeterminƒÉ statusul general
    if all(status != "unhealthy" for key, status in health_status.items() 
           if key.endswith(("database", "ai_detector"))):
        health_status["overall"] = "healthy"
        status_code = 200
    else:
        health_status["overall"] = "degraded"
        status_code = 503
    
    return JSONResponse(content=health_status, status_code=status_code)

# === ENDPOINT-URI ANALIZƒÇ TOXICITATE ===

@app.post("/api/analyze", response_model=AnalyzeMessageResponse)
@limiter.limit("30/minute")
async def analyze_message(
    request: Request,
    data: AnalyzeMessageRequest,
    background_tasks: BackgroundTasks,
    current_user: dict = Depends(get_current_user)
):
    """AnalizeazƒÉ un mesaj pentru toxicitate"""
    
    try:
        # AnalizeazƒÉ mesajul cu AI
        analysis_result = await analyze_toxicity(data.message, data.server_id)
        
        # GenereazƒÉ recomandƒÉri
        recommendations = []
        if analysis_result.is_toxic:
            if "profanity" in analysis_result.categories:
                recommendations.append("EvitƒÉ limbajul vulgar pentru o comunicare mai eficientƒÉ")
            if "harassment" in analysis_result.categories:
                recommendations.append("√éncearcƒÉ sƒÉ √Æ»õi exprimi punctul de vedere fƒÉrƒÉ a ataca persoana")
            if "hate_speech" in analysis_result.categories:
                recommendations.append("Limbajul discriminatoriu nu este tolerat")
        else:
            recommendations.append("Mesajul pare sƒÉ aibƒÉ un ton constructiv!")
        
        # SalveazƒÉ √Æn background dacƒÉ avem server_id »ôi user_id
        if data.server_id and data.user_id:
            background_tasks.add_task(
                save_analysis_to_db,
                data.server_id,
                data.user_id,
                data.message,
                analysis_result.dict()
            )
        
        return AnalyzeMessageResponse(
            analysis=analysis_result.dict(),
            recommendations=recommendations
        )
        
    except Exception as e:
        logger.error(f"Eroare la analiza mesajului: {e}")
        raise HTTPException(
            status_code=500,
            detail="Eroare la procesarea mesajului"
        )

@app.get("/api/servers/{server_id}/stats", response_model=ServerStatsResponse)
@limiter.limit("10/minute")
async def get_server_stats(
    request: Request,
    server_id: int,
    days: int = 30,
    current_user: dict = Depends(get_current_user),
    server_access = Depends(validate_server_access)
):
    """Ob»õine statisticile pentru un server"""
    
    try:
        db = await get_database()
        
        # Ob»õine serverul
        server = await db.get_server_by_discord_id(server_id)
        if not server:
            raise HTTPException(
                status_code=404,
                detail="Serverul nu a fost gƒÉsit"
            )
        
        # Ob»õine analytics
        analytics = await db.get_server_analytics(server.id, days)
        
        return ServerStatsResponse(
            server_id=server_id,
            stats=analytics["summary"],
            daily_stats=analytics["daily_stats"],
            top_categories=analytics["top_categories"]
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Eroare la ob»õinerea statisticilor server: {e}")
        raise HTTPException(
            status_code=500,
            detail="Eroare la procesarea cererii"
        )

@app.get("/api/servers/{server_id}/users/top", response_model=TopUsersResponse)
@limiter.limit("5/minute")
async def get_top_toxic_users(
    request: Request,
    server_id: int,
    limit: int = 10,
    current_user: dict = Depends(get_current_user),
    server_access = Depends(validate_server_access)
):
    """Ob»õine top utilizatori cu toxicitate ridicatƒÉ"""
    
    try:
        db = await get_database()
        
        # Ob»õine serverul
        server = await db.get_server_by_discord_id(server_id)
        if not server:
            raise HTTPException(
                status_code=404,
                detail="Serverul nu a fost gƒÉsit"
            )
        
        # Ob»õine top utilizatori
        top_users = await db.get_top_toxic_users(server.id, limit)
        
        return TopUsersResponse(
            users=top_users,
            total_count=len(top_users)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Eroare la ob»õinerea top utilizatori: {e}")
        raise HTTPException(
            status_code=500,
            detail="Eroare la procesarea cererii"
        )

@app.get("/api/users/{user_id}/stats", response_model=UserStatsResponse)
@limiter.limit("20/minute")
async def get_user_stats(
    request: Request,
    user_id: int,
    current_user: dict = Depends(get_current_user)
):
    """Ob»õine statisticile pentru un utilizator"""
    
    try:
        db = await get_database()
        
        # Ob»õine utilizatorul
        user = await db.get_user_by_discord_id(user_id)
        if not user:
            raise HTTPException(
                status_code=404,
                detail="Utilizatorul nu a fost gƒÉsit"
            )
        
        # Ob»õine mesajele toxice recente
        recent_toxic = await db.get_user_toxic_messages(user.id, limit=10)
        
        # FormateazƒÉ mesajele pentru response
        formatted_messages = []
        for msg in recent_toxic:
            formatted_messages.append({
                "content": msg.content[:100] + "..." if len(msg.content) > 100 else msg.content,
                "toxicity_score": msg.analysis.toxicity_score,
                "categories": msg.analysis.categories,
                "created_at": msg.created_at.isoformat(),
                "bypass_detected": msg.analysis.bypass_detected
            })
        
        return UserStatsResponse(
            user_id=user_id,
            username=user.username,
            stats={
                "total_messages": user.total_messages,
                "toxic_messages": user.toxic_messages,
                "warnings": user.warnings,
                "toxicity_ratio": user.toxicity_ratio,
                "last_activity": user.last_activity.isoformat() if user.last_activity else None
            },
            recent_toxic_messages=formatted_messages
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Eroare la ob»õinerea statisticilor utilizator: {e}")
        raise HTTPException(
            status_code=500,
            detail="Eroare la procesarea cererii"
        )

@app.post("/api/servers/{server_id}/config", response_model=BaseResponse)
@limiter.limit("5/minute")
async def update_server_config(
    request: Request,
    server_id: int,
    config_data: ServerConfigRequest,
    current_user: dict = Depends(get_current_user),
    server_access = Depends(validate_server_access)
):
    """ActualizeazƒÉ configura»õia unui server"""
    
    try:
        db = await get_database()
        
        # Ob»õine sau creeazƒÉ serverul
        server = await db.get_server_by_discord_id(server_id)
        if not server:
            # CreeazƒÉ server nou cu configura»õia default
            server = await db.create_or_update_server(
                discord_id=server_id,
                name=f"Server {server_id}",
                settings=config_data.dict()
            )
        else:
            # ActualizeazƒÉ configura»õia existentƒÉ
            await db.update_server_settings(server_id, config_data.dict())
        
        return BaseResponse(
            message="Configura»õia serverului a fost actualizatƒÉ cu succes"
        )
        
    except Exception as e:
        logger.error(f"Eroare la actualizarea configura»õiei server: {e}")
        raise HTTPException(
            status_code=500,
            detail="Eroare la actualizarea configura»õiei"
        )

@app.post("/api/moderation/action", response_model=BaseResponse)
@limiter.limit("10/minute")
async def create_moderation_action(
    request: Request,
    action_data: ModerationActionRequest,
    current_user: dict = Depends(get_current_user)
):
    """CreeazƒÉ o ac»õiune de moderare"""
    
    try:
        db = await get_database()
        
        # Ob»õine utilizatorul target
        user = await db.get_user_by_discord_id(action_data.user_id)
        if not user:
            raise HTTPException(
                status_code=404,
                detail="Utilizatorul nu a fost gƒÉsit"
            )
        
        # ValideazƒÉ durata pentru timeout/ban
        if action_data.action_type in ['timeout', 'ban'] and not action_data.duration:
            raise HTTPException(
                status_code=400,
                detail="Durata este obligatorie pentru timeout »ôi ban"
            )
        
        # Pentru moment, salvƒÉm doar √Æn baza de date
        # √én implementarea completƒÉ, aici ai trimite comanda la bot-ul Discord
        # prin webhook sau mesaj √Æn coadƒÉ
        
        return BaseResponse(
            message=f"Ac»õiunea {action_data.action_type} a fost √ÆnregistratƒÉ pentru utilizatorul {action_data.user_id}"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Eroare la crearea ac»õiunii de moderare: {e}")
        raise HTTPException(
            status_code=500,
            detail="Eroare la procesarea ac»õiunii"
        )

# === BACKGROUND TASKS ===

async def save_analysis_to_db(server_id: int, user_id: int, content: str, analysis: Dict):
    """SalveazƒÉ analiza √Æn baza de date (background task)"""
    try:
        db = await get_database()
        
        # Ob»õine/creeazƒÉ serverul »ôi utilizatorul
        server = await db.get_server_by_discord_id(server_id)
        if not server:
            server = await db.create_or_update_server(
                discord_id=server_id,
                name=f"Server {server_id}"
            )
        
        user = await db.get_user_by_discord_id(user_id)
        if not user:
            user = await db.create_or_update_user(
                discord_id=user_id,
                username=f"User {user_id}"
            )
        
        # SalveazƒÉ mesajul (folosim timestamp ca message_id fictiv)
        fake_message_id = int(datetime.utcnow().timestamp() * 1000000)
        
        await db.save_message_analysis(
            discord_message_id=fake_message_id,
            server_id=server.id,
            user_id=user.id,
            channel_id=0,  # Canal necunoscut pentru analizƒÉ manualƒÉ
            content=content,
            analysis_result=analysis
        )
        
        # ActualizeazƒÉ contoarele utilizatorului
        await db.increment_user_message_count(user_id, analysis.get('is_toxic', False))
        
        logger.info(f"AnalizƒÉ salvatƒÉ: server={server_id}, user={user_id}, toxic={analysis.get('is_toxic', False)}")
        
    except Exception as e:
        logger.error(f"Eroare la salvarea analizei √Æn DB: {e}")

async def periodic_stats_update():
    """Task periodic pentru actualizarea statisticilor"""
    while True:
        try:
            await asyncio.sleep(3600)  # RuleazƒÉ la fiecare orƒÉ
            
            db = await get_database()
            
            # Ob»õine toate serverele active
            servers_collection = db.get_collection('servers')
            
            async for server_doc in servers_collection.find({"is_active": True}):
                try:
                    # ActualizeazƒÉ statisticile zilnice pentru fiecare server
                    await db.update_daily_stats(server_doc["_id"])
                    logger.debug(f"Stats actualizate pentru server {server_doc['discord_id']}")
                    
                except Exception as e:
                    logger.error(f"Eroare la actualizarea stats pentru server {server_doc['discord_id']}: {e}")
            
            logger.info("üìä Task periodic stats completat")
            
        except Exception as e:
            logger.error(f"Eroare √Æn task periodic stats: {e}")

# === MIDDLEWARE PENTRU LOGGING ===

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Middleware pentru logging requests"""
    start_time = datetime.utcnow()
    
    response = await call_next(request)
    
    if config.fastapi.log_requests:
        process_time = (datetime.utcnow() - start_time).total_seconds()
        logger.info(
            f"{request.method} {request.url.path} - "
            f"Status: {response.status_code} - "
            f"Time: {process_time:.3f}s"
        )
    
    return response

# === WEBHOOK ENDPOINT PENTRU DISCORD BOT ===

@app.post("/api/webhook/discord/message")
@limiter.limit("100/minute")
async def discord_message_webhook(
    request: Request,
    message_data: Dict[str, Any],
    background_tasks: BackgroundTasks
):
    """Webhook pentru primirea mesajelor de la bot-ul Discord"""
    
    # VerificƒÉ autentificarea webhook-ului
    auth_header = request.headers.get("Authorization")
    expected_token = f"Bearer {config.fastapi.secret_key}"
    
    if auth_header != expected_token:
        raise HTTPException(
            status_code=401,
            detail="Webhook unauthorized"
        )
    
    try:
        # ProceseazƒÉ mesajul √Æn background
        background_tasks.add_task(process_discord_message, message_data)
        
        return {"status": "received"}
        
    except Exception as e:
        logger.error(f"Eroare la procesarea webhook Discord: {e}")
        raise HTTPException(
            status_code=500,
            detail="Eroare la procesarea mesajului"
        )

async def process_discord_message(message_data: Dict[str, Any]):
    """ProceseazƒÉ un mesaj venit de la Discord bot"""
    try:
        # Extrage datele mesajului
        content = message_data.get("content", "")
        server_id = message_data.get("server_id")
        user_id = message_data.get("user_id")
        channel_id = message_data.get("channel_id")
        message_id = message_data.get("message_id")
        
        if not all([content, server_id, user_id, channel_id, message_id]):
            logger.warning("Date incomplete √Æn webhook Discord")
            return
        
        # AnalizeazƒÉ mesajul
        analysis_result = await analyze_toxicity(content, server_id)
        
        # SalveazƒÉ √Æn baza de date
        db = await get_database()
        
        # Ob»õine/creeazƒÉ entitƒÉ»õile necesare
        server = await db.get_server_by_discord_id(server_id)
        if not server:
            server = await db.create_or_update_server(
                discord_id=server_id,
                name=f"Server {server_id}"
            )
        
        user = await db.get_user_by_discord_id(user_id)
        if not user:
            user = await db.create_or_update_user(
                discord_id=user_id,
                username=f"User {user_id}"
            )
        
        # SalveazƒÉ mesajul
        await db.save_message_analysis(
            discord_message_id=message_id,
            server_id=server.id,
            user_id=user.id,
            channel_id=channel_id,
            content=content,
            analysis_result=analysis_result.dict()
        )
        
        # ActualizeazƒÉ contoarele
        await db.increment_user_message_count(user_id, analysis_result.is_toxic)
        
        logger.info(f"Mesaj Discord procesat: {message_id}, toxic={analysis_result.is_toxic}")
        
    except Exception as e:
        logger.error(f"Eroare la procesarea mesajului Discord: {e}")

# === FUNC»öIA PRINCIPALƒÇ ===

def create_app() -> FastAPI:
    """Factory pentru crearea aplica»õiei FastAPI"""
    return app

if __name__ == "__main__":
    # RuleazƒÉ serverul √Æn modul development
    uvicorn.run(
        "main:app",
        host=config.fastapi.host,
        port=config.fastapi.port,
        reload=config.fastapi.reload,
        log_level="info"
    )